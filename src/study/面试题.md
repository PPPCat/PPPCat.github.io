# 面试题



#### var、let、const的区别

**var声明的变量，其作用域是全局作用域或函数作用域**

**let和const是块作用域**

```javascript
var a = "codevar";
console.log(a)//codevar;
function nf(){
    var b = "hi";
}
console.log(b);//error:b is not defind
```

```javascript
let times = 4;
if(items > 3){
    let a = "codelet";
    console.log(a);//codelet
}
console.log(a);//a is not defind
```

**var变量可以更新和重新声明**

**let变量可以更新但不能重新声明**

**const变量不能更新也不能重新声明**

```javascript
var x = 1;
var x = 2;
console.log(x);//2
```

```javascript
let a = "codelet";
let a = "hhhh";//error: a has already been declared
```

```javascript
const a = "codeconst";
a = "jjjj";//error:assignment to constant ariable
const a = "jjjj";//error:a has already been declared
```

在变量提升方面，它们都被提升到作用域的顶部。但是，var变量会被初始化为undefind，let和const不会被初始化。

```javascript
console.log(message);//undefind(js引擎会自动声明，理论结果是报错)
message = "hello";
console.log(message);//hello
```



###### 箭头函数和普通函数的区别

**this指向不同**

**箭头函数中的this只在箭头函数定义时就决定的**

```javascript
let obj = {
    a:function(){
        console.log(this);
    }
    b:()=>{
        console.log(this);
    }
}
obj.a();//obj
obj.b();//window//obj是在全局作用域中定义的，因此箭头函数 b的 this就是全局对象
```

**箭头函数的this指向定义的时候，外层的第一个普通函数的this**

```javascript
let obj = {
    run:function(){
        console.log('run',this);
        return ()=>{
            console.log(this);
        }
    }
}
obj.run().call(window);//run {run: f}
                       //{run: f}
```

**箭头函数的this不可修改（call、apply、bind）**

```javascript
obj.run().call(window);//run {run: f}
                       //{run: f}
```

**箭头函数不能new（不能作为构造函数）**

**箭头函数没有prototype原型**

**箭头函数没有arguments**

```javascript
let run = ()=>{
    return 111;
}
console.log(new run());//error
console.log(run.prototye);//error
let run1 = ()=>{
    console.log(arguments);
}
run();//error: arguments is not defind
```



###### promise和ajax的区别及async和await的区别

**Promise 和 AJAX 的区别**

| 特性         | Promise                                    | AJAX                                        |
| ------------ | ------------------------------------------ | ------------------------------------------- |
| **本质**     | 一种异步编程的解决方案（对象）             | 一种技术（Asynchronous JavaScript and XML） |
| **用途**     | 管理异步操作，解决回调地狱问题             | 浏览器与服务器进行异步通信的技术            |
| **层级**     | 语言层面的标准（ES6）                      | 浏览器提供的 API（XMLHttpRequest）          |
| **状态**     | 有明确的状态（pending/fulfilled/rejected） | 无内置状态管理机制                          |
| **链式调用** | 支持 `.then().catch()`链式调用             | 需要嵌套回调                                |
| **错误处理** | 有统一的 `.catch()`错误处理机制            | 需要手动检查状态码和错误                    |
| **现代替代** | Fetch API 基于 Promise                     | 正在被 Fetch API 取代                       |

```javascript
//ajax传统写法
const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data');
xhr.onload = function() {
  if (xhr.status === 200) {
    console.log(xhr.responseText);
  } else {
    console.error('Error:', xhr.statusText);
  }
};
xhr.onerror = function() {
  console.error('Request failed');
};
xhr.send();
//Promise封装ajax
function ajaxPromise(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.onload = () => resolve(xhr.responseText);
    xhr.onerror = () => reject(xhr.statusText);
    xhr.send();
  });
}

ajaxPromise('https://api.example.com/data')
  .then(data => console.log(data))
  .catch(error => console.error(error));
```

**Async/Await 和 Promise 的区别**

| 特性         | Promise                            | Async/Await                      |
| ------------ | ---------------------------------- | -------------------------------- |
| **语法**     | 链式调用（`.then().catch()`）      | 同步写法（使用 `await`关键字）   |
| **可读性**   | 回调嵌套可能导致可读性下降         | 代码更线性，更接近同步代码的写法 |
| **错误处理** | 使用 `.catch()`或链式处理          | 使用 `try/catch`块               |
| **调试**     | 调试较困难（多个 `.then()`块）     | 调试更直观（像同步代码一样）     |
| **返回值**   | 总是返回 Promise 对象              | `async`函数总是返回 Promise      |
| **适用场景** | 简单的异步操作或需要精细控制的情况 | 复杂的异步流程控制               |

```javascript
//Promise
function fetchData() {
  return fetch('https://api.example.com/data')
    .then(response => {
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }
      return response.json();
    })
    .then(data => {
      console.log(data);
      return processData(data);
    })
    .catch(error => {
      console.error('Error:', error);
    });
}
//a/a
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    const data = await response.json();
    console.log(data);
    return processData(data);
  } catch (error) {
    console.error('Error:', error);
  }
}
```

**现代开发中的典型使用**

```javascript
// 使用 Fetch API（基于 Promise） + Async/Await
async function getData() {
  try {
    const response = await fetch('https://api.example.com/data');
    if (!response.ok) throw new Error('HTTP error');
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Fetch failed:', error);
    throw error;
  }
}

// 调用
getData()
  .then(data => console.log(data))
  .catch(error => console.error('Final error:', error));
```

**如何选择**

使用 AJAX：

​     需要支持非常旧的浏览器

​     需要精细控制请求过程（如进度事件）

使用 Promise：

​     简单的异步操作

​     需要兼容较新但不是最新的浏览器

使用 Async/Await：

​    现代浏览器或 Node.js 环境

​    复杂的异步流程控制

​    追求代码可读性和可维护性