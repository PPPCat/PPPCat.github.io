# 面试题



### 1.var、let、const的区别

**var声明的变量，其作用域是全局作用域或函数作用域**

**let和const是块作用域**

```javascript
var a = "codevar";
console.log(a)//codevar;
function nf(){
    var b = "hi";
}
console.log(b);//error:b is not defind
```

```javascript
let times = 4;
if(items > 3){
    let a = "codelet";
    console.log(a);//codelet
}
console.log(a);//a is not defind
```

**var变量可以更新和重新声明**

**let变量可以更新但不能重新声明**

**const变量不能更新也不能重新声明**

```javascript
var x = 1;
var x = 2;
console.log(x);//2
```

```javascript
let a = "codelet";
let a = "hhhh";//error: a has already been declared
```

```javascript
const a = "codeconst";
a = "jjjj";//error:assignment to constant ariable
const a = "jjjj";//error:a has already been declared
```

在变量提升方面，它们都被提升到作用域的顶部。但是，var变量会被初始化为undefind，let和const不会被初始化。

```javascript
console.log(message);//undefind(js引擎会自动声明，理论结果是报错)
message = "hello";
console.log(message);//hello
```



### 2.箭头函数和普通函数的区别

**this指向不同**

**箭头函数中的this只在箭头函数定义时就决定的**

```javascript
let obj = {
    a:function(){
        console.log(this);
    }
    b:()=>{
        console.log(this);
    }
}
obj.a();//obj
obj.b();//window//obj是在全局作用域中定义的，因此箭头函数 b的 this就是全局对象
```

**箭头函数的this指向定义的时候，外层的第一个普通函数的this**

```javascript
let obj = {
    run:function(){
        console.log('run',this);
        return ()=>{
            console.log(this);
        }
    }
}
obj.run().call(window);//run {run: f}
                       //{run: f}
```

**箭头函数的this不可修改（call、apply、bind）**

```javascript
obj.run().call(window);//run {run: f}
                       //{run: f}
```

**箭头函数不能new（不能作为构造函数）**

**箭头函数没有prototype原型**

**箭头函数没有arguments**

```javascript
let run = ()=>{
    return 111;
}
console.log(new run());//error
console.log(run.prototye);//error
let run1 = ()=>{
    console.log(arguments);
}
run();//error: arguments is not defind
```



### 3.promise和ajax的区别及async和await的区别

###### **Promise 和 AJAX 的区别**

| 特性         | Promise                                    | AJAX                                        |
| ------------ | ------------------------------------------ | ------------------------------------------- |
| **本质**     | 一种异步编程的解决方案（对象）             | 一种技术（Asynchronous JavaScript and XML） |
| **用途**     | 管理异步操作，解决回调地狱问题             | 浏览器与服务器进行异步通信的技术            |
| **层级**     | 语言层面的标准（ES6）                      | 浏览器提供的 API（XMLHttpRequest）          |
| **状态**     | 有明确的状态（pending/fulfilled/rejected） | 无内置状态管理机制                          |
| **链式调用** | 支持 `.then().catch()`链式调用             | 需要嵌套回调                                |
| **错误处理** | 有统一的 `.catch()`错误处理机制            | 需要手动检查状态码和错误                    |
| **现代替代** | Fetch API 基于 Promise                     | 正在被 Fetch API 取代                       |

```javascript
//ajax传统写法
const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data');
xhr.onload = function() {
  if (xhr.status === 200) {
    console.log(xhr.responseText);
  } else {
    console.error('Error:', xhr.statusText);
  }
};
xhr.onerror = function() {
  console.error('Request failed');
};
xhr.send();
//Promise封装ajax
function ajaxPromise(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.onload = () => resolve(xhr.responseText);
    xhr.onerror = () => reject(xhr.statusText);
    xhr.send();
  });
}

ajaxPromise('https://api.example.com/data')
  .then(data => console.log(data))
  .catch(error => console.error(error));
```

###### **Async/Await 和 Promise 的区别**

| 特性         | Promise                            | Async/Await                      |
| ------------ | ---------------------------------- | -------------------------------- |
| **语法**     | 链式调用（`.then().catch()`）      | 同步写法（使用 `await`关键字）   |
| **可读性**   | 回调嵌套可能导致可读性下降         | 代码更线性，更接近同步代码的写法 |
| **错误处理** | 使用 `.catch()`或链式处理          | 使用 `try/catch`块               |
| **调试**     | 调试较困难（多个 `.then()`块）     | 调试更直观（像同步代码一样）     |
| **返回值**   | 总是返回 Promise 对象              | `async`函数总是返回 Promise      |
| **适用场景** | 简单的异步操作或需要精细控制的情况 | 复杂的异步流程控制               |

```javascript
//Promise
function fetchData() {
  return fetch('https://api.example.com/data')
    .then(response => {
      if (!response.ok) {
        throw new Error('Network response was not ok');
      }
      return response.json();
    })
    .then(data => {
      console.log(data);
      return processData(data);
    })
    .catch(error => {
      console.error('Error:', error);
    });
}
//a/a
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    const data = await response.json();
    console.log(data);
    return processData(data);
  } catch (error) {
    console.error('Error:', error);
  }
}
```

**现代开发中的典型使用**

```javascript
// 使用 Fetch API（基于 Promise） + Async/Await
async function getData() {
  try {
    const response = await fetch('https://api.example.com/data');
    if (!response.ok) throw new Error('HTTP error');
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Fetch failed:', error);
    throw error;
  }
}

// 调用
getData()
  .then(data => console.log(data))
  .catch(error => console.error('Final error:', error));
```

###### **如何选择**

使用 AJAX：

​     需要支持非常旧的浏览器

​     需要精细控制请求过程（如进度事件）

使用 Promise：

​     简单的异步操作

​     需要兼容较新但不是最新的浏览器

使用 Async/Await：

​    现代浏览器或 Node.js 环境

​    复杂的异步流程控制

​    追求代码可读性和可维护性



### 4.什么是防抖和节流？有什么区别？如何实现？

###### 是什么

本质上是优化高频率执行代码的一种手段

如：浏览器的 `resize`、`scroll`、`keypress`、`mousemove` 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能

为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 **防抖（debounce）** 和 **节流（throttle）** 的方式来减少调用频率

定义

- 节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效
- 防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时

一个经典的比喻:

想象每天上班大厦底下的电梯。把电梯完成一次运送，类比为一次函数的执行和响应

假设电梯有两种运行策略 `debounce` 和 `throttle`，超时设定为15秒，不考虑容量限制

电梯第一个人进来后，15秒后准时运送一次，这是节流

电梯第一个人进来后，等待15秒。如果过程中又有人进来，15秒等待重新计时，直到15秒后开始运送，这是防抖

###### 代码实现

**节流**

完成节流可以使用时间戳与定时器的写法

使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行

```javascript
function throttled1(fn, delay = 500) {
    let oldtime = Date.now()
    return function (...args) {
        let context = this
        let newtime = Date.now()
        if (newtime - oldtime >= delay) {
            fn.apply(context, args)
            oldtime = Date.now()
        }
    }
}
```

watch写法

```javascript
import { ref, watch } from 'vue'

const scrollPosition = ref(0)
let lastExecuted = 0
const throttleDelay = 200 // 200毫秒节流间隔

watch(scrollPosition, (newPosition) => {
  const now = Date.now()
  if (now - lastExecuted >= throttleDelay) {
    console.log('处理滚动位置:', newPosition)
    // 实际处理逻辑...
    lastExecuted = now
  }
})
```

使用定时器写法，`delay`毫秒后第一次执行，第二次事件停止触发后依然会再一次执行

```javascript
function throttled2(fn, delay = 500) {
    let timer = null
    return function (...args) {
        if (!timer) {
            timer = setTimeout(() => {
                fn.apply(this, args)
                timer = null
            }, delay);
        }
    }
}
```

可以将时间戳写法的特性与定时器写法的特性相结合，实现一个更加精确的节流。实现如下

```javascript
function throttled(fn, delay) {
    let timer = null
    let starttime = Date.now()
    return function () {
        let curTime = Date.now() // 当前时间
        let remaining = delay - (curTime - starttime)  // 从上一次到现在，还剩下多少多余时间
        let context = this
        let args = arguments
        clearTimeout(timer)
        if (remaining <= 0) {
            fn.apply(context, args)
            starttime = Date.now()
        } else {
            timer = setTimeout(fn, remaining);//在剩余时间(remaining)结束后执行函数
        }
    }
}
```

**防抖**

简单版本的实现

```javascript
function debounce(func, wait) {
    let timeout;

    return function () {
        let context = this; // 保存this指向
        let args = arguments; // 拿到event对象

        clearTimeout(timeout)
        timeout = setTimeout(function(){
            func.apply(context, args)
        }, wait);
    }
}
```

watch实现

```javascript
import { ref, watch } from 'vue'

const searchQuery = ref('')
let timeoutId

watch(searchQuery, (newQuery) => {
  clearTimeout(timeoutId) // 清除之前的定时器
  timeoutId = setTimeout(() => {
    console.log('执行搜索:', newQuery)
    // 实际搜索逻辑...
  }, 500) // 500毫秒防抖间隔
})
```

防抖如果需要立即执行，可加入第三个参数用于判断，实现如下：

```javascript
function debounce(func, wait, immediate) {

    let timeout;

    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout); // 减少函数开销，增加可读性
                                            //定时器被清除仍会保留之前的定时器ID（未被设为null）
        if (immediate) {
            let callNow = !timeout; // 第一次会立即执行，以后只有事件执行后才会再次触发
            timeout = setTimeout(function () {
                timeout = null;
            }, wait)
            if (callNow) {
                func.apply(context, args)
            }
        }
        else {
            timeout = setTimeout(function () {
                func.apply(context, args)
            }, wait);
        }
    }
}
```

###### 区别

相同点：

- 都可以通过使用 `setTimeout` 实现
- 目的都是，降低回调执行频率。节省计算资源

不同点：

- 函数防抖，在一段连续操作结束后，处理回调，利用`clearTimeout`和 `setTimeout`实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能
- 函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次

例如，都设置时间频率为500ms，在2秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在2s后，只会执行一次



### 5.手写Promise

```javascript
class MyPromise {
  constructor(executor) {
    this.state = 'pending';  // 'fulfilled' or 'rejected'
    this.value = undefined;
    this.reason = undefined;
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];

    const resolve = (value) => {
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
        this.onFulfilledCallbacks.forEach(fn => fn());
      }
    };
    const reject = (reason) => {
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn => fn());
      }
    };
//一旦调用 resolve，状态转为 fulfilled，保存值，并执行所有保存的“成功回调”。
//同理 reject 是失败时调用

    try {
      executor(resolve, reject);  // 立即执行
    } catch (err) {
      reject(err);
    }
//执行传进来的 executor（就是 new MyPromise((resolve, reject) => { ... }) 的参数）。
//如果在执行时抛出异常，也会调用 reject(err)。
  }

  then(onFulfilled, onRejected) {
    // 处理非函数参数
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
    onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };
//.then() 必须传两个回调函数，分别处理成功和失败；
//如果用户没传，提供默认处理（传递之前的value）（成功就原样返回，失败就继续抛错）。
      
    const nextPromise = new MyPromise((resolve, reject) => {
      const run = (callback) => {
        try {
          const result = callback(this.state === 'fulfilled' ? this.value : this.reason);
          // 如果回调返回的是 Promise，等待它 resolve/reject
          if (result instanceof MyPromise) {
            result.then(resolve, reject);
          } else {
            resolve(result);
          }
        } catch (err) {
          reject(err);
        }
      };
//run(callback) 用来执行用户的回调函数。
//如果返回的是一个 Promise（嵌套 Promise），就等待它完成。
//否则就直接调用 resolve(result)，实现 .then().then() 链式。
        
      if (this.state === 'fulfilled') {
        queueMicrotask(() => run(onFulfilled));
      } else if (this.state === 'rejected') {
        queueMicrotask(() => run(onRejected));
      } else {
        this.onFulfilledCallbacks.push(() => queueMicrotask(() => run(onFulfilled)));
        this.onRejectedCallbacks.push(() => queueMicrotask(() => run(onRejected)));
      }
    });
//如果当前 Promise 已经是 fulfilled 或 rejected，就排进微任务队列立即执行回调；
//如果状态是 pending，说明是异步操作，先把回调保存起来，等 resolve/reject 时再统一执行。

    return nextPromise;
      //为了支持 .then().then()，每次 .then() 必须返回一个新的 Promise，这也是原生 Promise 设计中的核心
  }
}
```



### 6.pnpm和npm的区别

#### 6.1安装机制

**npm**
 传统的包管理方式，安装时会把所有依赖包及其依赖的依赖（递归依赖）都完整复制到项目的 `node_modules` 文件夹内。
 这样会导致 `node_modules` 目录很庞大，磁盘占用大，安装速度相对慢。

npm@3之前安装方式为嵌套安装，每个依赖项都会创建自己的node_modules文件夹，会造成package会创建太深的依赖树，导致目录路径过长，同时不同依赖项中可能会创建相同依赖包，造成不必要存储开支

因此npm@3和yarn使用扁平结构,node_modules中所有包放在同一层级，但是会带来依赖结构的不确定性造成扁平化结构的不确定性，为此package_lock.json和yarn.lock为此诞生 

**幽灵依赖**：某个包没有在package.json被依赖（这个包可能是其他包的依赖项被扁平化提升），但是用户能够引用这个包

**npm分身**：提升机制可能导致大量依赖被重复安装

**pnpm**
 采用了一种叫做“内容可寻址存储（content-addressable storage）”的机制，依赖包只在全局的存储区保存一份副本，项目中则通过硬链接（hard link）指向这些包。
 因此，节省磁盘空间，安装速度更快，且避免重复安装相同版本的依赖。

**幽灵依赖问题**：pnpm会在根目录下创建隐藏的.pnpm文件夹，以平铺形式存储所有包，通过包名和版本号来实现相同的模块不同版本之间的隔离和复用；由于不存在提升所以不存在幽灵依赖

**npm分身问题**：pnpm使用名为.pnpm-store的存储目录，存储所有项目依赖包信息的hard link硬链接，通过硬链接直接访问文件资源，如两个依赖包有相同依赖项，其中一个可通过hard link使用

但是硬链接只能用于文件而非目录，项目还需要通过sym link软链接到.pnpm的node modules目录

#### 6.2性能

**pnpm** 的安装速度通常比 npm 快，尤其是在大型项目和依赖复杂时优势明显。

**pnpm** 由于依赖共享，能节省大量磁盘空间。

#### 6.3node_modules 结构

**npm** 生成的 `node_modules` 文件夹是扁平化的（自 npm 3 以后），但会把依赖都复制到项目中，依赖树可能较复杂。

**pnpm** 采用严格的依赖结构，每个包依赖只能访问声明的依赖，避免模块冲突和“幽灵依赖”问题。

#### 6.4兼容性

**npm** 作为 Node.js 官方推荐的包管理器，兼容性最好，使用最广泛。

**pnpm** 需要 Node.js 版本支持硬链接，但现在支持已经很广泛，大多数项目可以无缝使用。

#### 6.5CLI 命令

**基本命令类似**，比如 `install`、`add`、`remove` 等，但 pnpm 的一些命令有更丰富的功能。

你可以把 pnpm 看作是更高效的替代品，学习成本低。

#### 6.6总结

| 特点         | npm                    | pnpm                       |
| ------------ | ---------------------- | -------------------------- |
| 安装机制     | 复制依赖包到项目目录   | 全局存储，硬链接到项目目录 |
| 磁盘空间占用 | 大                     | 小                         |
| 安装速度     | 较慢                   | 快                         |
| node_modules | 扁平化结构，可能有冲突 | 严格结构，避免幽灵依赖     |
| 兼容性       | 最广泛                 | 兼容良好                   |



### 7.this的指向，改变this的指向

无论函数原本属于谁，从哪里来，判断this的唯一依据，就是此刻函数的执行由哪个对象调用

```js
let xiaoming = {
    shit:function(){
        setTimeout(function(){
            console.log(this)
        })
    }
}
xiaoming.shit();//this指向window
```

一旦函数以回调参数的形式传递给别人，函数的执行权也被让渡，同时参数又是局部变量，不属于任何对象，因此找不到调用者于是指向window

**改变this的指向**

1.把关键字转为变量

```javascript
let xiaoming = {
    age:18
    introduce:function(){
        let $this = this;//
        setTimeout(function(){
            console.log($this.age)
        },1000)
    }
}
xiaoming.introduce();
```

2.绑定函数的this

```javascript
class MyCom{
    constructor(){
        this.value = 100;
    }
    getValue(){
        return this.value;
    }
}
let btn{
    value = 200;
}
let mc = new MyCom();
btn.getValue = mc.getValue;
console.log(btn.getValue());//200
```

执行函数的对象变更，函数的this改变，可使用函数自带的bind（）方法绑定对象

```javascript
function test(){}
let newTest = test.bind(xiaoming)//bind不改变函数，而是生产新函数，所以要声明一个函数来承接
newTest();//this永远指向小明
```

对于MyCom例子可在构造中添加

```javascript
this.getValue = this.getValue.bind(this);
```

3.箭头函数

```javascript
let xiaoming = {
    age:18
    introduce:function(){
        setTimeout(()=>{
            console.log($this.age)
        },1000)
    }
}
xiaoming.introduce();
```

4.call/apply函数方法

```javascript
test()//第一次执行：this指向lilei
test()//第二次执行：this指向xiaoming
test()//第三次执行：this指向wangwei

test.call()//相当于test（）
test.call(lilei)//相当于lilei.test()//仅支持这一次调用
test.call(lilei,参数1,参数2)；
test.apply(lilei,[参数1,参数2,...])；
```

```javascript
func.apply(thisArg, [argsArray]);
```

| 参数        | 含义                           |
| ----------- | ------------------------------ |
| `thisArg`   | 函数运行时绑定的 `this` 值     |
| `argsArray` | 一个包含参数的数组或类数组对象 |

| 方法      | 参数传递方式 | 示例                       |
| --------- | ------------ | -------------------------- |
| `call()`  | 逐个传参     | `func.call(this, a, b)`    |
| `apply()` | 数组传参     | `func.apply(this, [a, b])` |



### 8.CSS 盒模型

页面布局中，一个元素的外边距（margin）、 边框（border）、内边距（padding）、内容（content）组成一个盒模型。盒模型可分为**标准盒模型** 和 **代替（IE）盒模型**



#### 8.1标准盒模型

在标准模型中，如果你给盒设置 `width` 和 `height`，实际设置的是内容区域( *content box*)的宽高。 `padding` 和 `border` 再加上设置的宽高一起决定整个盒子的大小

```css
 .box {
  width: 100px;
  height: 50px;
  margin: 10px;
  padding: 25px;
  border: 5px solid black;
}
```

如果使用标准模型，元素总宽度 = 160px （100+25+25+5+5），总高度 = 110px (50 + 25 + 25 + 5 + 5)，即内容区域`content box`加 `padding` 和 `border`

**注**: margin 不计入实际大小 —— 当然，它会影响盒子在页面所占空间，但是影响的是盒子外部空间。



#### 8.2代替（IE）盒模型

你可能会认为盒子的大小还要加上边框和内边距，这样很麻烦。 因为这个原因，css还有一个替代盒模型。使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。使用上面相同的样式得到总宽高是 width = 100px, height = 50px。

默认浏览器会使用标准模型。如果需要使用替代模型，您可以通过为其设置 `box-sizing: border-box` 来实现。 这样就可以告诉浏览器使用 `border-box` 来定义区域，从而设定您想要的大小

```css
.box { 
  box-sizing: border-box; 
} 
```

#### 8.3box-sizing属性

CSS中的 **`box-sizing`** 属性用于告诉浏览器如何计算一个元素是总宽度和总高度

在 [CSS盒子模型 (opens new window)](https://developer.mozilla.org/zh-CN/docs/CSS/Box_model)的默认定义里，你对一个元素所设置的 [`width` (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/CSS/width)与 [`height` (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/CSS/height)只会应用到这个元素的内容区。如果这个元素有任何的 [`border` (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/CSS/border)或 [`padding` (opens new window)](https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding)，绘制到屏幕上时的盒子宽度和高度会加上设置的边框和内边距值。这意味着当你调整一个元素的宽度和高度时需要时刻注意到这个元素的边框和内边距。当我们实现响应式布局时，这个特点尤其烦人。

box-sizing 属性可以被用来调整这些表现:

- `content-box` 是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。

  - 尺寸计算公式：

    `width` = 内容的宽度

    `height` = 内容的高度

- `border-box` 告诉浏览器：你想要设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px，那么这100px会包含它的border和padding，内容区的实际宽度是width减去(border + padding)的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。

  - 尺寸计算公式：

    *`width` = border + padding + 内容的宽度*

    *`height` = border + padding + 内容的高度*

#### 8.4边距塌陷

边距塌陷是刻意设计，用于解决段落间垂直方向的正margin值的差别

相邻的两个纯粹块级元素box或者父子box同时设置垂直方向margin（水平反向不存在边距塌陷）

**边距塌陷取值**

- 都是正数取最大值
- 相同取其一
- 正负都有取最大整数和最小负数之和
- 都是负数取最小

**对于父子元素边距塌陷**S

- 对父元素设置`position:relative;`，对子元素设置`position:abslute;`此时对子元素设置margin不会影响父元素和相邻元素的外边距
- 设置子元素为`display:inline-block;`行内块级元素，因为边距塌陷仅存在于块级元素
- 设置子元素为`position:relative;`，但是margin-top将不再能使用，并且没有真正解决外边距塌陷
- 设置float
- 设置BFC`display: flow-root;`或者`overflow: hidden;` 
- 设置父元素`padding`或者`border`





垂直水平居中
css自适应
es6常用语法有哪些
let const区别
js作用域有哪些
改变this指向的方式有哪些
手写防抖节流（我的博客有）
深拷贝、浅拷贝
事件循环机制
闭包
原型、原型链
https和http的区别
xss（如何预防）
csrf（如何预防）
重绘重排
打开url发生了什么
http缓存
vue2和vue3的diff算法有啥不同，还有响应式原理的不同点是什么
nextTick是什么
vuerouter的模式有哪些，底层是怎么样的（我的博客有）
vuex为啥是区分mutation为同步，不能为异步

### .webpack和vite的区别

webpack和vite是两种广泛使用的构建工具，它们分别代表传统和现代的开发理念

#### .1核心架构对比

构建方式上

**Webpack：Bundle-based**

1. 遍历依赖
2. 全量打包
3. 启动服务器

特点

- 启动慢
- HMR相对慢
- 配置复杂

**Vite：ESM-based**

1. 启动服务器
2. 按需编译
3. 动态加载

特点

- 启动块
- HMR急速（局部刷新）
- 配置简单（开箱即用）

#### .2开发理念：从打包一切到按需加载

webpack的核心思想是“先打包后运行”。它会在启动开发服务器之前，分析项目的所有依赖关系，生产一个完整的依赖图，并将所有模块打包成一个或者多个文件。这种方式类似于“把所有材料准备好，再开始做菜”，虽然稳妥但是启动速度慢

vite拥抱了现代浏览器的能力，充分利用了原生ES Modules（ESM）的支持，采用“按需加载”的方式。开发服务器无需提前打包所有模块，而是更具浏览器的请求动态编译所需的文件。这种方式更像是“现做现卖，需要什么拿什么”，极大的提升了开发效率



#### .3冷启动速度

冷启动速度是开发者最直观的感受之一。webpack的启动过程包括以来分析、模块打包和开发服务器启动。对于大型项目，这个过程可能需要几十秒甚至几分钟，特别是首次启动时。

而vite的冷启动几乎可以成为即开即用。他直接启动开发服务器，只有在浏览器请求某个模块时才会动态编译相关文件。得益于这种按需加载的机制，vite的情动速度通常比webpack快10-100倍



#### .4热更新(HMR)

热更新（HMR）是开发过程中频繁使用的功能，它直接影响开发体验。

- webpack：检测到代码修改时，需要重新打包受影响的模块及其相关依赖。随着项目规模的增大，模块依赖链边长，热更新相关速度会逐渐变慢
- vite：只会精确编译修改的模块，并立即将更新推送到浏览器。由于它充分利用了浏览器缓存机制，热更新速度几乎与项目大小无关，开发体验更加流畅



#### .5配置复杂度

webpack的配置灵活性极高，但是也因此显得复杂。粗学者需要花费大量时间学习如何配置loader和plugin，才能充分发挥webpack的能力

vite则以开箱即用为设计理念，提供了简单直观的默认配置。对于大多数项目来说，vite的默认配置已经足够，开发者只需少量调整



#### .6生产环境构建：成熟度和速度的权衡

webpack：

- 统一打包流程
- 配置复杂度
- 插件生态成熟

vite

- 开发：原生ESM
- 生产：Rollup打包
- 预设优化配置

在生产环境中，webpack经过多年验证，支持多种优化手段（如代码分割、tree shaking等），适合处理复杂的企业级项目

vite在生产环境中使用Rollup打包，同样支持各种优化功能，虽然在超大型项目中，vite的表现可能不如webpack稳定，但是它的构建速度和输出结果依旧令人满意

#### .7生态兼容性：老牌工具VS新兴力量

webpack作为前端构建工具，拥有庞大的生态系统和社区支持。几乎所有的前端框架和库都提供了针对webpack的插件和loader。对旧浏览器的兼容性更好，适合需要支持广泛浏览器的项目

vite起步晚但是发展迅速，得益于现代前端框架（如vue和react）的支持，vite的生态系统正在快速拓展，组件成为开发者的新宠。由于vite基于ES Modules，需要@vitejs/plugin-legacy等插件来支持旧浏览器（如IE11）

 



git rebase和git merge的区别
git revert和git reset的区别
git flow是什么

